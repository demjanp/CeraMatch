
optimize load_drawing_data if possible

FIX history behaviour
	
	History
		state: clusters, nodes, edges, labels, positions
		
		.clear()
		.can_undo()	= True/False
		.can_redo()	= True/False
		.undo()		= clusters, nodes, edges, labels, positions
		.redo()		= clusters, nodes, edges, labels, positions
		.save()

	save history on:
		mouse release
		graph_view.set_data
		graph_view.add_cluster


--------------------

calculate minimum number of cluster re-assignments so auto-clustering matches manual clustering
compare vs. randomized

--------------------

connect with Deposit

Sample.Id
Sample.Profile
Sample.Radius

store distances in Deposit
weight(Sample.diam_dist.Sample) = diam_dist
weight(Sample.axis_dist.Sample) = axis_dist
weight(Sample.h_dist.Sample) = h_dist
weight(Sample.h_rim_dist.Sample) = h_rim_dist

store clustering in Deposit
CMCluster/CMNode.contains.Sample
CMCluster.Name = [cluster name]
CMNode.linked.CMNode
CMNode.Name = [node name]

--------------------

D[i, j] = [diam_dist, ax_dist, h_dist, h_rim_dist]


get_clusters(D, limit = 0.68)
	
	normalize D: move each component to 0 and divide by mean
	limit = D.mean() * 0.68
	
	1. each fragment is assigned to its own cluster
	2. calculate distance between all clusters
		if any component of distance between members of two clusters > limit: their distance is infinite
		otherwise their distance is the mean of all components of distances of their members
	3. join clusters with the smallest distance
	4. repeat steps 2 and 3 while any two clusters have a finite distance

--------------------------------

A hierarchical clustering algorithm based on the Hungarian method
https://doi.org/10.1016/j.patrec.2008.04.003

http://www.cs.utexas.edu/~grauman/courses/spring2008/slides/ShapeMatching.pdf

check if nonlinear / piecewise linear algebra (deep learning) can be used for clustering
check Unsupervised learning using Neural Networks

distmax - try sort using global maximum optimization so that 10% most distant samples have maximum (min / avg / median?) distance

try using directed hamming distances (A -> B != B -> A)
